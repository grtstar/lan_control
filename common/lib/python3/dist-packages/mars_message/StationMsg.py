"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct
import json

class StationMsg(object):
    __slots__ = ["packNum", "dataLen", "_00packType", "_01workMode", "_02install", "_03install", "_04install", "_05keyType", "_06keyType", "_07keyType", "_08keyType", "_09LED0", "_10LED1", "_11LED2", "_12LED3", "_13randNum", "_14randChl", "_15version"]

    __typenames__ = ["int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t", "int8_t"]

    __dimensions__ = [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None]

    def __init__(self):
        self.packNum = 0
        self.dataLen = 0
        self._00packType = 0
        self._01workMode = 0
        self._02install = 0
        self._03install = 0
        self._04install = 0
        self._05keyType = 0
        self._06keyType = 0
        self._07keyType = 0
        self._08keyType = 0
        self._09LED0 = 0
        self._10LED1 = 0
        self._11LED2 = 0
        self._12LED3 = 0
        self._13randNum = 0
        self._14randChl = 0
        self._15version = 0

    def encode(self):
        buf = BytesIO()
        buf.write(StationMsg._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">bbbbbbbbbbbbbbbbbb", self.packNum, self.dataLen, self._00packType, self._01workMode, self._02install, self._03install, self._04install, self._05keyType, self._06keyType, self._07keyType, self._08keyType, self._09LED0, self._10LED1, self._11LED2, self._12LED3, self._13randNum, self._14randChl, self._15version))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != StationMsg._get_packed_fingerprint():
            raise ValueError("Decode error")
        return StationMsg._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = StationMsg()
        self.packNum, self.dataLen, self._00packType, self._01workMode, self._02install, self._03install, self._04install, self._05keyType, self._06keyType, self._07keyType, self._08keyType, self._09LED0, self._10LED1, self._11LED2, self._12LED3, self._13randNum, self._14randChl, self._15version = struct.unpack(">bbbbbbbbbbbbbbbbbb", buf.read(18))
        return self
    _decode_one = staticmethod(_decode_one)

    def _get_hash_recursive(parents):
        if StationMsg in parents: return 0
        tmphash = (0x10a69d5cee7b065b) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if StationMsg._packed_fingerprint is None:
            StationMsg._packed_fingerprint = struct.pack(">Q", StationMsg._get_hash_recursive([]))
        return StationMsg._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", StationMsg._get_packed_fingerprint())[0]

    def from_dict(self, j):
        self.packNum = j["packNum"]
        self.dataLen = j["dataLen"]
        self._00packType = j["_00packType"]
        self._01workMode = j["_01workMode"]
        self._02install = j["_02install"]
        self._03install = j["_03install"]
        self._04install = j["_04install"]
        self._05keyType = j["_05keyType"]
        self._06keyType = j["_06keyType"]
        self._07keyType = j["_07keyType"]
        self._08keyType = j["_08keyType"]
        self._09LED0 = j["_09LED0"]
        self._10LED1 = j["_10LED1"]
        self._11LED2 = j["_11LED2"]
        self._12LED3 = j["_12LED3"]
        self._13randNum = j["_13randNum"]
        self._14randChl = j["_14randChl"]
        self._15version = j["_15version"]

    def to_dict(self):
        j = {}
        j["packNum"] = self.packNum
        j["dataLen"] = self.dataLen
        j["_00packType"] = self._00packType
        j["_01workMode"] = self._01workMode
        j["_02install"] = self._02install
        j["_03install"] = self._03install
        j["_04install"] = self._04install
        j["_05keyType"] = self._05keyType
        j["_06keyType"] = self._06keyType
        j["_07keyType"] = self._07keyType
        j["_08keyType"] = self._08keyType
        j["_09LED0"] = self._09LED0
        j["_10LED1"] = self._10LED1
        j["_11LED2"] = self._11LED2
        j["_12LED3"] = self._12LED3
        j["_13randNum"] = self._13randNum
        j["_14randChl"] = self._14randChl
        j["_15version"] = self._15version
        return j

